<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Space Invaders</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    canvas {
      border: 1px solid #333;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const BLACK = '#000000';
    const WHITE = '#FFFFFF';
    const GREEN = '#00FF00';
    const RED = '#FF0000';
    const BLUE = '#0000FF';
    const YELLOW = '#FFFF00';
    const PURPLE = '#800080';

    // Заглушки для изображений
    let playerImg = createPlaceholderImage(40, 40, GREEN);
    let bulletImg = createPlaceholderImage(5, 15, BLUE);
    
    // Разные типы врагов
    let enemyImages = [
      createPlaceholderImage(40, 40, RED),    // тип 0 - слабый (1 попадание)
      createPlaceholderImage(40, 40, YELLOW), // тип 1 - средний (2 попадания)
      createPlaceholderImage(40, 40, PURPLE)  // тип 2 - сильный (3 попадания)
    ];

    loadImages();

    function createPlaceholderImage(width, height, color) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
      return canvas;
    }

    function loadImages() {
      function loadImage(name, scale = 1) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = function () {
            if (scale !== 1) {
              const canvas = document.createElement('canvas');
              canvas.width = img.width * scale;
              canvas.height = img.height * scale;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              resolve(canvas);
            } else {
              resolve(img);
            }
          };
          img.onerror = function () { resolve(createPlaceholderImage(40, 40, RED)); };
          img.src = `data/${name}`;
        });
      }
      
      Promise.all([
        loadImage("player.png", 1),
        loadImage("bullet.png", 1),
        loadImage("enemy1.png", 1),
        loadImage("enemy2.png", 1),
        loadImage("enemy3.png", 1)
      ]).then(([player, bullet, enemy1, enemy2, enemy3]) => {
        playerImg = player;
        bulletImg = bullet;
        enemyImages = [enemy1, enemy2, enemy3];
        
        playerWidth = playerImg.width;
        playerHeight = playerImg.height;
        bulletWidth = bulletImg.width;
        bulletHeight = bulletImg.height;
        enemyWidth = enemyImages[0].width;
        enemyHeight = enemyImages[0].height;
        
        playerX = canvas.width / 2 - playerWidth / 2;
      }).catch(err => {
        console.error(err);
      });
    }

    function scaleImage(image, scale) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = image.width * scale;
      tempCanvas.height = image.height * scale;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);
      return tempCanvas;
    }

    // Игрок
    let playerWidth = playerImg.width;
    let playerHeight = playerImg.height;
    let playerX = canvas.width / 2 - playerWidth / 2;
    const playerY = canvas.height - playerHeight - 20;
    const playerSpeed = 5;

    // Пули
    let bullets = [];
    const bulletSpeed = 7;
    let bulletWidth = bulletImg.width;
    let bulletHeight = bulletImg.height;

    // Враги
    let enemies = [];
    let enemyWidth = enemyImages[0].width;
    let enemyHeight = enemyImages[0].height;
    let enemySpeed = 1;           // текущая скорость (будет меняться динамически)
    let baseEnemySpeed = 1;       // базовая скорость уровня
    let maxEnemies = 0;           // стартовое количество врагов в уровне
    const enemyDrop = 30;
    let enemyDirection = 1;

    // Уровни
    const levels = [
      {
        speed: 1,
        layout: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      {
        speed: 1.5,
        layout: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ]
      },
      {
        speed: 2,
        layout: [
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ]
      },
      {
        speed: 2.5,
        layout: [
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
          [2, 1, 1, 1, 1, 1, 1, 1, 1, 2],
          [2, 1, 0, 0, 0, 0, 0, 0, 1, 2],
          [2, 1, 1, 1, 1, 1, 1, 1, 1, 2]
        ]
      },
      {
        speed: 3,
        layout: [
          [2, 1, 2, 1, 2, 1, 2, 1, 2, 1],
          [1, 2, 1, 2, 1, 2, 1, 2, 1, 2],
          [2, 1, 2, 1, 2, 1, 2, 1, 2, 1],
          [1, 2, 1, 2, 1, 2, 1, 2, 1, 2],
          [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
        ]
      }
    ];
    
    let currentLevel = 0;
    let levelComplete = false;
    let levelStartTime = 0;
    const levelTransitionTime = 2000;

    // Создание врагов для текущего уровня
    function createEnemies() {
      const level = levels[currentLevel];
      baseEnemySpeed = level.speed; // сохраняем базовую скорость для уровня
      enemySpeed = baseEnemySpeed;  // текущая скорость сбрасываем к базовой
      
      const enemiesList = [];
      for (let row = 0; row < level.layout.length; row++) {
        for (let col = 0; col < level.layout[row].length; col++) {
          const enemyType = level.layout[row][col];
          if (enemyType !== undefined) {
            const enemyX = 100 + col * 60;
            const enemyY = 50 + row * 50;
            enemiesList.push({
              x: enemyX,
              y: enemyY,
              type: enemyType,
              hits: 0,
              hitsRequired: enemyType + 1 // тип 0 требует 1 попадание, тип 1 - 2 и т.д.
            });
          }
        }
      }
      maxEnemies = enemiesList.length; // сохраняем стартовое количество врагов
      return enemiesList;
    }

    enemies = createEnemies();

    // Счет и состояние игры
    let score = 0;
    let lives = 3;
    let gameOver = false;
    let gameWon = false;
    const font = '20px Arial';
    const bigFont = '50px Arial';

    // Обработка клавиш
    const keys = {
      left: false,
      right: false,
      space: false,
      r: false
    };

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
      if (e.key === ' ') keys.space = true;
      if (e.key.toLowerCase() === 'r') keys.r = true;
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
      if (e.key === ' ') keys.space = false;
      if (e.key.toLowerCase() === 'r') keys.r = false;
    });
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function update() {
      if (!gameOver && !gameWon && !levelComplete) {
        // Движение игрока
        if (keys.left && playerX > 0) {
          playerX -= playerSpeed;
        }
        if (keys.right && playerX < canvas.width - playerWidth) {
          playerX += playerSpeed;
        }

        // Стрельба
        if (keys.space) {
          keys.space = false; // Чтобы не было непрерывного выстрела
          const bulletX = playerX + (playerWidth - bulletWidth) / 2;
          const bulletY = playerY;
          bullets.push([bulletX, bulletY]);
        }

        // Движение пуль
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i][1] -= bulletSpeed;
          if (bullets[i][1] < 0) {
            bullets.splice(i, 1);
          }
        }

        // Чем меньше врагов осталось, тем выше скорость их движения
        if (enemies.length > 0) {
          const speedFactor = Math.min(2, maxEnemies / (enemies.length * 2)); // 1.0 вначале, растёт по мере убийства врагов, но не меньше 0.5
          enemySpeed = baseEnemySpeed * speedFactor;
        }

        // Движение врагов
        let moveDown = false;
        for (const enemy of enemies) {
          enemy.x += enemySpeed * enemyDirection;

          // Проверка достижения границы
          if (enemy.x <= 0 || enemy.x >= canvas.width - enemyWidth) {
            moveDown = true;
          }
        }

        if (moveDown) {
          enemyDirection *= -1;
          for (const enemy of enemies) {
            enemy.y += enemyDrop;
          }
        }

        // Проверка столкновений пуль с врагами
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (bullet[0] > enemy.x && bullet[0] < enemy.x + enemyWidth &&
                bullet[1] > enemy.y && bullet[1] < enemy.y + enemyHeight) {
              bullets.splice(i, 1);
              enemy.hits++;
              
              if (enemy.hits >= enemy.hitsRequired) {
                // Уничтожение врага
                score += 10 * (enemy.type + 1); // больше очков за сильных врагов
                enemies.splice(j, 1);
              }
              break;
            }
          }
        }

        // Проверка поражения
        for (const enemy of enemies) {
          if (enemy.y > canvas.height - 100) {
            lives--;
            if (lives <= 0) {
              gameOver = true;
            } else {
              enemies = createEnemies();
              bullets = [];
              playerX = canvas.width / 2 - playerWidth / 2;
            }
            break;
          }
        }

        // Проверка завершения уровня
        if (enemies.length === 0) {
          levelComplete = true;
          levelStartTime = Date.now();
          
          // Проверка завершения игры (последний уровень)
          if (currentLevel >= levels.length - 1) {
            gameWon = true;
          }
        }
      }
      
      // Переход на следующий уровень
      if (levelComplete && !gameWon && Date.now() - levelStartTime > levelTransitionTime) {
        currentLevel++;
        enemies = createEnemies();
        bullets = [];
        playerX = canvas.width / 2 - playerWidth / 2;
        levelComplete = false;
      }

      // Рестарт 
      if ((gameOver || gameWon) && keys.r) {
        keys.r = false;
        currentLevel = 0;
        enemies = createEnemies();
        bullets = [];
        playerX = canvas.width / 2 - playerWidth / 2;
        score = 0;
        lives = 3;
        gameOver = false;
        gameWon = false;
        levelComplete = false;
      }
    }

    function draw() {
      ctx.fillStyle = BLACK;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Игрок
      ctx.drawImage(playerImg, playerX, playerY);

      // Пули
      for (const bullet of bullets) {
        ctx.drawImage(bulletImg, bullet[0], bullet[1]);
      }

      // Враги
      for (const enemy of enemies) {
        ctx.drawImage(enemyImages[enemy.type], enemy.x, enemy.y);
        
        // Отображение здоровья для врагов, требующих более 1 попадания
        if (enemy.hitsRequired > 1) {
          ctx.fillStyle = WHITE;
          ctx.font = '12px Arial';
          ctx.fillText(`${enemy.hitsRequired - enemy.hits}`, enemy.x + enemyWidth/2 - 5, enemy.y + enemyHeight + 15);
        }
      }

      // Счет и жизни
      ctx.fillStyle = WHITE;
      ctx.font = font;
      ctx.fillText(`Score: ${score}`, 10, 30);
      ctx.fillText(`Lives: ${lives}`, canvas.width - 120, 30);
      ctx.fillText(`Level: ${currentLevel + 1}/${levels.length}`, canvas.width / 2 - 50, 30);

      // Сообщение о переходе на следующий уровень
      if (levelComplete && !gameWon) {
        ctx.fillStyle = YELLOW;
        ctx.font = bigFont;
        const levelText = `LEVEL ${currentLevel + 2}`;
        ctx.fillText(levelText, canvas.width / 2 - ctx.measureText(levelText).width / 2,
          canvas.height / 2);
      }

      // Сообщения о победе/поражении
      if (gameOver) {
        ctx.fillStyle = RED;
        ctx.font = bigFont;
        const gameOverText = "GAME OVER";
        ctx.fillText(gameOverText, canvas.width / 2 - ctx.measureText(gameOverText).width / 2,
          canvas.height / 2 - 25);

        ctx.fillStyle = WHITE;
        ctx.font = font;
        const restartText = "Press R to restart";
        ctx.fillText(restartText, canvas.width / 2 - ctx.measureText(restartText).width / 2,
          canvas.height / 2 + 50);
      }

      if (gameWon) {
        ctx.fillStyle = GREEN;
        ctx.font = bigFont;
        const gameWonText = "YOU WIN!";
        ctx.fillText(gameWonText, canvas.width / 2 - ctx.measureText(gameWonText).width / 2,
          canvas.height / 2 - 25);

        ctx.fillStyle = WHITE;
        ctx.font = font;
        const restartText = "Press R to restart";
        ctx.fillText(restartText, canvas.width / 2 - ctx.measureText(restartText).width / 2,
          canvas.height / 2 + 50);
      }
    }

    gameLoop();
  </script>
</body>
</html>
